#include "../headers/allHeaders.h"

#include <filesystem>
#include <cmath>

#include <chrono>


// bool Test::FxnOddEven(long vertexId)
// {
//     if(vertexId % 2 == 1)
//         return true;
//     return false;
// }

// bool Test::FxnOddEven_(long v1Id, long v2Id)
// {
//     if((v1Id + v2Id) % 2 == 1)
//         return true;
//     return false;
// }

bool OddEven(long vertexId)
{
    if(vertexId % 2 == 1)      //!! Should be odd, then only true
        return true;
    return false;
//    return true;
}

bool OddEven_(long v1Id, long v2Id)
{
    if((v1Id + v2Id) % 2 == 1) //!Sum should be odd, then only true
        return true;
    return false;
//    return true;
}


std::vector<long> Test::GenerateRandomIntegers(long minInteger, 
                                               long maxInteger, 
                                               long totalNumbers)
{
    srand(100);  //Changed from rand(). srand() seeds rand for you.

    std::vector<long> retV;
    for(long i = 0; i < totalNumbers; ++i)
        retV.emplace_back(rand() % maxInteger + minInteger);

    return retV;
}    

void Test::TestVertexSubset(Graph &g,
                      VertexSubset &vs,
                      long nodesCountInSubset,
                      std::string &logFile)
{
    std::fstream fileStream(logFile, std::ios::app);

    //fileStream << "Beginning the test vertex subset function" << std::endl;

    //!Set this vertex subset
    std::vector<long> subsetIds = GenerateRandomIntegers(0,
                                               g.getNumberVertices(),
                                               nodesCountInSubset);

    std::sort(subsetIds.begin(), subsetIds.end());
    subsetIds.erase(std::unique(subsetIds.begin(), subsetIds.end()), subsetIds.end());

    vs.setVertexSubset(subsetIds);
    fileStream << "Number of vertices: "<< vs.getVertexSubsetLength() << " | Outdegree: " << vs.getVertexSubsetOutDegree(g) << std::endl;
    //fileStream << "Below is the input vector subset:" << std::endl;
    vs.LogIntoFile(fileStream);

    //VertexSubset o = Interface::VertexMap(vs, &OddEven);
    VertexSubset o2 = Interface::EdgeMapDenseWrite(g, vs, &OddEven_, &OddEven);

    std::cout << "Dense Done" << std::endl;
    VertexSubset o1 = Interface::EdgeMapSparse(g, vs, &OddEven_, &OddEven);
    std::cout << "Sparse Done" << std::endl;

    //!Error between edge map sparse and edge map dense should be zero
    bool thereIsAnError = false;
    if(o1.getVertexSubsetLength() != o2.getVertexSubsetLength())
    {
        //!If length is different, flag this error
        fileStream << "Different sizes generated by edgeMapSparse and edgeMapDense" << std::endl;
        thereIsAnError = true;
    }
    else
    {
        for(size_t i = 0; i < o1.getVertexSubsetLength(); ++i)
        {
            long error = o1.getVertexSubset()[i] - o2.getVertexSubset()[i];
            if(error != 0)
            {
                fileStream << "Different subsets generated by edgeMapSparse and edgeMapDense" << std::endl;
                thereIsAnError = true;
                break;
            }   
        }
    }
    fileStream << " " << std::endl;
    fileStream << " " << std::endl;    
//     //Testing: VertexMap
//     //std::cout << "Vertex Map Function output: " << std::endl;
//     VertexSubset o = Interface::VertexMap(vs, &OddEven);
//     //o.printVertexSubset();
//     //std::cout << "After calling Vertex Map Function" << std::endl;

//     //Testing EdgeMapSparse
// //    std::cout << "Before calling Edge Map Sparse Function" << std::endl;
//     VertexSubset o1 = Interface::EdgeMapSparse(g, vs, &OddEven_, &OddEven);
// //    o1.printVertexSubset();
// //    std::cout << "After calling Edge Map Sparse Function" << std::endl;

//     //Testing EdgeMapDense
// //    std::cout << "Before calling Edge Map Dense Function" << std::endl;
//     VertexSubset o2 = Interface::EdgeMapDenseWrite(g, vs, &OddEven_, &OddEven);
// //    o2.printVertexSubset();
// //    std::cout << "After calling Edge Map Dense Function" << std::endl;

//     //!Error between edge map sparse and edge map dense should be zero
//     bool thereIsAnError = false;
//     if(o1.getVertexSubsetLength() != o2.getVertexSubsetLength())
//     {
//         //!If length is different, flag this error
//         thereIsAnError = true;
//     }
//     if(thereIsAnError == true)
//     {
//         std::cout << "Error Present" << std::endl;
//     }

//     for(size_t i = 0; i < o1.getVertexSubsetLength(); ++i)
//     {
//         long error = o1.getVertexSubset()[i] - o2.getVertexSubset()[i];
//         if(error != 0)
//         {
//             thereIsAnError = true;
//             break;
//         }   
//     }

//     if(thereIsAnError == true)
//     {
//         std::cout << "Error Present" << std::endl;
//     }

//     std::cout << std::endl;
//     std::cout << std::endl;
}

void Test::DoTestingOnThisGraph(Graph &currGraph, std::string &logFile)
{
    std::cout << "Reached Here 3" << std::endl;
    long verticesCount = currGraph.getNumberVertices();

    std::vector<long> individualSubsetSizes;
    for(int i = 1; i <= 10; ++i)
    {
        long subSetSize = std::ceil(verticesCount * i * 10./100);
        individualSubsetSizes.push_back(subSetSize);
    }
    individualSubsetSizes.erase(std::unique(individualSubsetSizes.begin(), individualSubsetSizes.end()), individualSubsetSizes.end());

    // std::cout << "Running Seq" << std::endl;
    // bfs_s(currGraph,0);
    // std::cout << "Running Parallel" << std::endl;
    // bfs(currGraph,0);
    //for(int i = 0; i < 100; ++i)
    {
//        std::cout << "New Call" << " Root: " << i << std::endl;
        TestBFS(currGraph,1);
//        std::cout << "   " << std::endl;        
    }


    // for(auto &subSetSize : individualSubsetSizes)
    // {
    //     VertexSubset vs;

    //     std::fstream fileStream(logFile, std::ios::app);
    //     //fileStream << "Beginning of the testing on this graph function" << std::endl;
    //     fileStream << " " << std::endl;
    //     //fileStream << "Percentage of nodes selected for subset: "  << i * 10 << "%" <<std::endl;

    //     TestVertexSubset(currGraph,
    //                      vs,
    //                      subSetSize,
    //                      logFile);

    //     //fileStream << "Ending of the testing on this graph function" << std::endl;
    //     fileStream << " " << std::endl;
    //     //break;
    // }
}

//bool Test::CompareLayers(std::deque<std::atomic<long>> &layers, std::deque<long> &layers_s)
bool Test::CompareLayers(long* layers, long* layers_s)
{
    for(long i = 0; i < sizeof(layers)/sizeof(long); i++)
    {
        if(layers[i] != layers_s[i])
        {
            std::cout<<"Layers MisMatch at vertex"<<i<<std::endl;
            
            return false;
        }
           
    }
    //std::cout<<"Layers Match!"<<std::endl;
    return true;
}

void Test::TestBFS(Graph& currGraph, long root)
{
    // extern std::deque<std::atomic<long>> parents;
    // extern std::deque<std::atomic<long>> layers;
    // extern std::deque<long> parents_s;
    // extern std::deque<long> layers_s;
    extern long* parents;
    extern long* layers;
    extern long* parents_s;
    extern long* layers_s;

auto startS = std::chrono::high_resolution_clock::now();
    bfs_s(currGraph, root);
auto startP = std::chrono::high_resolution_clock::now();
    bfs(currGraph, root);
auto end = std::chrono::high_resolution_clock::now();
auto seqT = std::chrono::duration<double>(startP - startS);
auto parallelT = std::chrono::duration<double>(end - startP);


    std::cout << "Seq Time: " << seqT.count() << " Parallel Time: " << parallelT.count() << std::endl;
    CompareLayers(layers, layers_s);

    free(parents);
    free(layers);
    free(parents_s);
    free(layers_s);
}